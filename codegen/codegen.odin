package main

// Codegen tool: reads bld/*.odin and generates dist/lib/bld.odin bindings.

import "core:fmt"
import "core:os"
import "core:strings"

// A parsed type definition (verbatim source text).
Type_Def :: struct {
    name:   string,
    source: string, // Full definition including "Name :: struct { ... }"
}

// A parsed proc signature.
Proc_Sig :: struct {
    name:        string,   // e.g. "build"
    link_name:   string,   // e.g. "bld_build"
    params:      string,   // e.g. "config: Build_Config"
    returns:     string,   // e.g. "bool" or "([]u8, bool)" or ""
    is_variadic: bool,     // true if any param uses ..
    is_companion: bool,    // true if this is a _bld_xxx companion
}

// A parsed global variable.
Global_Var :: struct {
    name:      string,   // e.g. "minimal_log_level"
    link_name: string,   // e.g. "bld_minimal_log_level"
    type_name: string,   // e.g. "Log_Level"
}

BLD_VERSION :: "0.1.0"

main :: proc() {
    // Read all .odin files in bld/
    bld_dir := "bld"
    f, open_err := os.open(bld_dir)
    if open_err != nil {
        fmt.eprintln("Could not open bld/ directory:", open_err)
        os.exit(1)
    }
    defer os.close(f)

    infos, read_err := os.read_all_directory(f, context.temp_allocator)
    if read_err != nil {
        fmt.eprintln("Could not read bld/ directory:", read_err)
        os.exit(1)
    }
    defer os.file_info_slice_delete(infos, context.temp_allocator)

    // Collect all source file contents.
    Source_File :: struct {
        name:    string,
        content: string,
    }
    sources := make([dynamic]Source_File, context.temp_allocator)

    for info in infos {
        if !strings.has_suffix(info.name, ".odin") do continue
        path := fmt.tprintf("%s/%s", bld_dir, info.name)
        data, ok := os.read_entire_file_from_path(path, context.temp_allocator)
        if ok != nil {
            fmt.eprintfln("Could not read %s: %v", path, ok)
            os.exit(1)
        }
        append(&sources, Source_File{
            name    = strings.clone(info.name, context.temp_allocator),
            content = string(data),
        })
    }

    fmt.printfln("Read %d source files from bld/", len(sources))

    // Parse types, procs, and globals from all source files.
    type_defs := make([dynamic]Type_Def, context.temp_allocator)
    proc_sigs := make([dynamic]Proc_Sig, context.temp_allocator)
    global_vars := make([dynamic]Global_Var, context.temp_allocator)

    for src in sources {
        _parse_source(src.content, &type_defs, &proc_sigs, &global_vars)
    }

    fmt.printfln("Found %d types, %d procs, %d globals", len(type_defs), len(proc_sigs), len(global_vars))

    // Generate the bindings file.
    sb := strings.builder_make(context.temp_allocator)

    // Header.
    strings.write_string(&sb, "#+feature global-context\n\n")
    strings.write_string(&sb, "package bld\n\n")
    strings.write_string(&sb, "// Auto-generated by codegen \u2014 DO NOT EDIT.\n")
    strings.write_string(&sb, "// Run: odin run codegen -out:target/codegen && ./target/codegen\n\n")

    // Imports.
    strings.write_string(&sb, "import \"core:dynlib\"\n")
    strings.write_string(&sb, "import \"core:fmt\"\n")
    strings.write_string(&sb, "import \"core:mem\"\n")
    strings.write_string(&sb, "import \"core:os\"\n")
    strings.write_string(&sb, "import \"core:time\"\n\n")

    // Section 1: Metadata constants.
    strings.write_string(&sb, "// \u2500\u2500 Metadata \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n")
    fmt.sbprintf(&sb, "BLD_VERSION :: \"%s\"\n\n", BLD_VERSION)

    // Section 2: Type definitions.
    strings.write_string(&sb, "// \u2500\u2500 Types \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n")
    for td in type_defs {
        strings.write_string(&sb, td.source)
        strings.write_string(&sb, "\n\n")
    }

    // Section 3: API struct.
    strings.write_string(&sb, "// \u2500\u2500 API Struct \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n")
    strings.write_string(&sb, "@(private = \"file\")\n")
    strings.write_string(&sb, "_Bld_API :: struct {\n")

    // Only include exported procs (those with link_names).
    for ps in proc_sigs {
        if len(ps.link_name) == 0 do continue
        // Field name is the link_name without "bld_" prefix.
        field_name := ps.link_name[4:] if strings.has_prefix(ps.link_name, "bld_") else ps.link_name
        // Proc pointer types in structs cannot have default values — strip them.
        stripped_params := _strip_defaults(ps.params)
        fmt.sbprintf(&sb, "    %s: proc(%s)", field_name, stripped_params)
        if len(ps.returns) > 0 {
            fmt.sbprintf(&sb, " -> %s", ps.returns)
        }
        strings.write_string(&sb, ",\n")
    }

    strings.write_string(&sb, "    __handle: dynlib.Library,\n")
    strings.write_string(&sb, "}\n\n")

    // API instance.
    strings.write_string(&sb, "@(private = \"file\")\n")
    strings.write_string(&sb, "_api: _Bld_API\n\n")

    // Global variable pointers.
    if len(global_vars) > 0 {
        strings.write_string(&sb, "// \u2500\u2500 Globals (pointers into DLL memory) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n")
        for gv in global_vars {
            fmt.sbprintf(&sb, "%s: ^%s\n", gv.name, gv.type_name)
        }
        strings.write_string(&sb, "\n")
    }

    // Section 4: @(init) loader.
    strings.write_string(&sb, "// \u2500\u2500 Init \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n")
    strings.write_string(&sb, "@(init)\n")
    strings.write_string(&sb, "@(private = \"file\")\n")
    strings.write_string(&sb, "_load_bld :: proc() {\n")
    strings.write_string(&sb, "    LIB_DIR :: #directory\n\n")

    // Platform-specific dylib name.
    strings.write_string(&sb, "    when ODIN_OS == .Darwin {\n")
    strings.write_string(&sb, "        DYLIB_NAME :: \"libbld.dylib\"\n")
    strings.write_string(&sb, "    } else when ODIN_OS == .Linux {\n")
    strings.write_string(&sb, "        DYLIB_NAME :: \"libbld.so\"\n")
    strings.write_string(&sb, "    } else {\n")
    strings.write_string(&sb, "        #panic(\"Unsupported OS\")\n")
    strings.write_string(&sb, "    }\n\n")

    strings.write_string(&sb, "    dylib_path := fmt.tprintf(\"%s%s\", LIB_DIR, DYLIB_NAME)\n\n")

    strings.write_string(&sb, "    count, ok := dynlib.initialize_symbols(&_api, dylib_path, \"bld_\")\n")
    strings.write_string(&sb, "    if !ok {\n")
    strings.write_string(&sb, "        fmt.eprintfln(\"[bld] Could not load library at '%s': %s\", dylib_path, dynlib.last_error())\n")
    strings.write_string(&sb, "        os.exit(1)\n")
    strings.write_string(&sb, "    }\n\n")

    // Load global variable pointers (fail-fast on missing symbols).
    for gv in global_vars {
        // Use short 2-letter prefix for var names to match handwritten style.
        // minimal_log_level -> "ml", echo_actions -> "ea"
        short: string
        switch gv.name {
        case "minimal_log_level": short = "ml"
        case "echo_actions":      short = "ea"
        case:                     short = fmt.tprintf("%c%c", gv.name[0], gv.name[1])
        }
        strings.write_string(&sb, fmt.tprintf("    %s_ptr, %s_ok := dynlib.symbol_address(_api.__handle, \"%s\")\n",
            short, short, gv.link_name))
        strings.write_string(&sb, fmt.tprintf("    if !%s_ok {{\n", short))
        strings.write_string(&sb, fmt.tprintf("        fmt.eprintfln(\"[bld] Could not load '%s' from library\")\n", gv.name))
        strings.write_string(&sb, "        os.exit(1)\n")
        strings.write_string(&sb, "    }\n")
        strings.write_string(&sb, fmt.tprintf("    %s = (^%s)(%s_ptr)\n\n", gv.name, gv.type_name, short))
    }

    // Version mismatch warning using runtime lib_odin_version().
    strings.write_string(&sb, "    lib_version := _api.lib_odin_version()\n")
    strings.write_string(&sb, "    if lib_version != ODIN_VERSION {\n")
    strings.write_string(&sb, "        fmt.eprintfln(\n")
    strings.write_string(&sb, "            \"[bld] Warning: library compiled with Odin %s, you are using %s. ABI mismatch may cause crashes.\",\n")
    strings.write_string(&sb, "            lib_version, ODIN_VERSION,\n")
    strings.write_string(&sb, "        )\n")
    strings.write_string(&sb, "    }\n")
    strings.write_string(&sb, "}\n\n")

    // Section 5: Wrapper procs.
    strings.write_string(&sb, "// \u2500\u2500 Wrapper Procs \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\n")

    // For each exported proc, generate a wrapper.
    // Non-variadic procs: wrapper has same signature, forwards to _api.field.
    // Variadic companion procs: wrapper restores variadic syntax.
    for ps in proc_sigs {
        if len(ps.link_name) == 0 do continue
        if ps.is_companion do continue // Companions are internal — the wrapper uses the original name

        field_name := ps.link_name[4:] if strings.has_prefix(ps.link_name, "bld_") else ps.link_name

        // Build wrapper signature.
        fmt.sbprintf(&sb, "%s :: proc(%s)", ps.name, ps.params)
        if len(ps.returns) > 0 {
            fmt.sbprintf(&sb, " -> %s", ps.returns)
        }
        strings.write_string(&sb, " {\n")

        // Build the call.
        // Extract param names from the params string for forwarding.
        param_names := _extract_param_names(ps.params)
        call_args := strings.join(param_names, ", ", context.temp_allocator)

        if len(ps.returns) > 0 {
            fmt.sbprintf(&sb, "    return _api.%s(%s)\n", field_name, call_args)
        } else {
            fmt.sbprintf(&sb, "    _api.%s(%s)\n", field_name, call_args)
        }
        strings.write_string(&sb, "}\n\n")
    }

    // Generate variadic wrappers for companion procs.
    // These use the original proc name with variadic syntax, forwarding to the slice-taking API field.
    _generate_variadic_wrappers(&sb, proc_sigs[:])

    // Write the output file.
    output := strings.to_string(sb)

    // Ensure dist/lib/ exists.
    os.mkdir_all("dist/lib")

    err := os.write_entire_file("dist/lib/bld.odin", output)
    if err != nil {
        fmt.eprintln("Could not write dist/lib/bld.odin:", err)
        os.exit(1)
    }

    fmt.println("Generated dist/lib/bld.odin")
}

// Parse a single source file for types, procs, and globals.
@(private = "file")
_parse_source :: proc(
    content: string,
    type_defs: ^[dynamic]Type_Def,
    proc_sigs: ^[dynamic]Proc_Sig,
    global_vars: ^[dynamic]Global_Var,
) {
    lines := strings.split(content, "\n", context.temp_allocator)

    i := 0
    for i < len(lines) {
        line := lines[i]
        trimmed := strings.trim_space(line)

        // Skip empty lines, comments, imports, package declaration.
        if len(trimmed) == 0 || strings.has_prefix(trimmed, "//") ||
           strings.has_prefix(trimmed, "import ") || strings.has_prefix(trimmed, "package ") {
            i += 1
            continue
        }

        // Check for @(export, link_name="...") on the NEXT line's proc/global.
        if strings.has_prefix(trimmed, "@(export") {
            link_name := _extract_link_name(trimmed)

            // Look ahead for what this attribute applies to.
            // Could be a proc or a global variable.
            // Skip any additional attribute lines (like @(private)).
            j := i + 1
            for j < len(lines) {
                next := strings.trim_space(lines[j])
                if strings.has_prefix(next, "@(") || strings.has_prefix(next, "//") || len(next) == 0 {
                    j += 1
                    continue
                }
                break
            }

            if j < len(lines) {
                next_line := lines[j]
                next_trimmed := strings.trim_space(next_line)

                // Is it a global variable? Pattern: "name: Type = value"
                if _is_global_var(next_trimmed) {
                    gv := _parse_global_var(next_trimmed, link_name)
                    if len(gv.name) > 0 {
                        append(global_vars, gv)
                    }
                    i = j + 1
                    continue
                }

                // Is it a proc? Pattern: "name :: proc("
                if _is_proc_def(next_trimmed) {
                    // Collect the full proc signature (may span multiple lines).
                    sig_text := _collect_proc_signature(lines[:], j)
                    ps := _parse_proc_sig(sig_text, link_name)
                    if len(ps.name) > 0 {
                        append(proc_sigs, ps)
                    }
                    i = j + 1
                    continue
                }
            }

            i += 1
            continue
        }

        // Check for type definitions (no @(export) needed — types are copied verbatim).
        // Pattern: "Name :: struct {", "Name :: enum {", "Name :: bit_set[", "Name :: proc("
        // Only match top-level type defs (no leading whitespace in original line).
        if _is_type_def(trimmed) && len(line) > 0 && (line[0] >= 'A' && line[0] <= 'Z') {
            // Check if preceded by @(private...) — skip private types.
            is_private := false
            for k := i - 1; k >= 0 && k >= i - 3; k -= 1 {
                prev := strings.trim_space(lines[k])
                if strings.has_prefix(prev, "@(private") {
                    is_private = true
                    break
                }
                if len(prev) == 0 || strings.has_prefix(prev, "//") {
                    continue // skip blanks and comments
                }
                break // hit a non-attribute line, stop looking
            }
            if is_private {
                i = _skip_block(lines[:], i)
                continue
            }

            td := _collect_type_def(lines[:], i)
            if len(td.name) > 0 {
                append(type_defs, td)
            }
            // Skip past the type definition.
            i = _skip_block(lines[:], i)
            continue
        }

        i += 1
    }
}

// Extract link_name from @(export, link_name="bld_xxx").
@(private = "file")
_extract_link_name :: proc(attr_line: string) -> string {
    // Find link_name="
    idx := strings.index(attr_line, "link_name=\"")
    if idx < 0 do return ""
    start := idx + len("link_name=\"")
    end := strings.index(attr_line[start:], "\"")
    if end < 0 do return ""
    return attr_line[start:][:end]
}

// Check if a line is a global variable declaration.
// Pattern: "name: Type = value" at column 0 (no leading whitespace in original).
@(private = "file")
_is_global_var :: proc(line: string) -> bool {
    // Must contain ": " and " = " but NOT "::" (which is a constant/proc/type).
    if strings.contains(line, "::") do return false
    colon := strings.index(line, ":")
    if colon < 0 do return false
    // Name before colon must be a valid identifier (no spaces).
    name := strings.trim_space(line[:colon])
    if strings.contains(name, " ") do return false
    return true
}

// Parse a global variable declaration.
@(private = "file")
_parse_global_var :: proc(line: string, link_name: string) -> Global_Var {
    colon := strings.index(line, ":")
    if colon < 0 do return {}
    name := strings.trim_space(line[:colon])

    // Type is between ":" and "="
    rest := line[colon + 1:]
    eq := strings.index(rest, "=")
    type_name: string
    if eq >= 0 {
        type_name = strings.trim_space(rest[:eq])
    } else {
        type_name = strings.trim_space(rest)
    }

    return Global_Var{
        name      = strings.clone(name, context.temp_allocator),
        link_name = strings.clone(link_name, context.temp_allocator),
        type_name = strings.clone(type_name, context.temp_allocator),
    }
}

// Check if a line starts a proc definition.
@(private = "file")
_is_proc_def :: proc(line: string) -> bool {
    return strings.contains(line, ":: proc(") || strings.contains(line, ":: proc (")
}

// Check if a line starts a type definition.
// Must start with an uppercase letter (Ada_Case) and contain ":: struct", ":: enum", ":: bit_set", or ":: proc(".
@(private = "file")
_is_type_def :: proc(line: string) -> bool {
    if len(line) == 0 do return false
    // Must start with uppercase letter (type names are Ada_Case).
    first := line[0]
    if first < 'A' || first > 'Z' do return false

    if strings.contains(line, ":: struct {") || strings.contains(line, ":: struct{") do return true
    if strings.contains(line, ":: enum {") || strings.contains(line, ":: enum{") do return true
    if strings.contains(line, ":: bit_set[") do return true
    // Type alias: "Name :: proc("
    if strings.contains(line, ":: proc(") do return true

    return false
}

// Collect a complete type definition (may span multiple lines for structs/enums).
@(private = "file")
_collect_type_def :: proc(lines: []string, start: int) -> Type_Def {
    line := strings.trim_space(lines[start])

    // Extract name (everything before " :: ").
    name_end := strings.index(line, " :: ")
    if name_end < 0 do return {}
    name := line[:name_end]

    // For bit_set and type aliases (single line), just return the line.
    if strings.contains(line, ":: bit_set[") || !strings.contains(line, "{") {
        return Type_Def{
            name   = strings.clone(name, context.temp_allocator),
            source = strings.clone(line, context.temp_allocator),
        }
    }

    // For structs and enums, collect until closing "}".
    sb := strings.builder_make(context.temp_allocator)
    depth := 0
    for i := start; i < len(lines); i += 1 {
        l := lines[i]
        // Don't trim — preserve indentation.
        // But do trim leading whitespace for the first line if it's at file scope.
        if i == start {
            strings.write_string(&sb, strings.trim_space(l))
        } else {
            // Don't indent the closing brace of the outermost block.
            if strings.trim_space(l) == "}" {
                strings.write_string(&sb, "}")
            } else {
                strings.write_string(&sb, "    ") // Re-indent with 4 spaces.
                strings.write_string(&sb, strings.trim_space(l))
            }
        }
        strings.write_string(&sb, "\n")

        for ch in l {
            if ch == '{' do depth += 1
            if ch == '}' do depth -= 1
        }
        if depth <= 0 && i > start do break
        if depth <= 0 && strings.contains(l, "}") do break
    }

    source := strings.to_string(sb)
    // Trim trailing newline.
    if len(source) > 0 && source[len(source)-1] == '\n' {
        source = source[:len(source)-1]
    }

    return Type_Def{
        name   = strings.clone(name, context.temp_allocator),
        source = strings.clone(source, context.temp_allocator),
    }
}

// Skip past a block (struct/enum body) to find the next statement.
@(private = "file")
_skip_block :: proc(lines: []string, start: int) -> int {
    line := lines[start]
    if !strings.contains(line, "{") {
        return start + 1 // Single-line definition.
    }

    depth := 0
    for i := start; i < len(lines); i += 1 {
        for ch in lines[i] {
            if ch == '{' do depth += 1
            if ch == '}' do depth -= 1
        }
        if depth <= 0 do return i + 1
    }
    return len(lines)
}

// Collect a proc signature that may span multiple lines.
@(private = "file")
_collect_proc_signature :: proc(lines: []string, start: int) -> string {
    sb := strings.builder_make(context.temp_allocator)
    paren_depth := 0
    found_open := false

    for i := start; i < len(lines); i += 1 {
        line := lines[i]
        trimmed := strings.trim_space(line)

        if i == start {
            strings.write_string(&sb, trimmed)
        } else {
            strings.write_string(&sb, " ")
            strings.write_string(&sb, trimmed)
        }

        for ch in line {
            if ch == '(' {
                paren_depth += 1
                found_open = true
            }
            if ch == ')' do paren_depth -= 1
        }

        // We're done when we've closed all parens and found the opening brace.
        if found_open && paren_depth <= 0 {
            break
        }
    }

    return strings.to_string(sb)
}

// Parse a proc signature string into a Proc_Sig.
@(private = "file")
_parse_proc_sig :: proc(sig: string, link_name: string) -> Proc_Sig {
    // Format: "name :: proc(params) -> returns {"
    // or:     "name :: proc(params) {"
    // or:     "_bld_name :: proc(params) {"

    name_end := strings.index(sig, " :: proc(")
    if name_end < 0 do return {}
    name := sig[:name_end]

    // Check if this is a companion proc.
    is_companion := strings.has_prefix(name, "_bld_")

    // Extract params: everything between first "(" and matching ")".
    open := strings.index(sig, "(")
    if open < 0 do return {}

    // Find matching close paren.
    depth := 0
    close := -1
    for idx := open; idx < len(sig); idx += 1 {
        if sig[idx] == '(' do depth += 1
        if sig[idx] == ')' {
            depth -= 1
            if depth == 0 {
                close = idx
                break
            }
        }
    }
    if close < 0 do return {}

    params := strings.trim_right(strings.trim_space(sig[open+1:close]), ",")

    // Check for variadic.
    is_variadic := strings.contains(params, "..")

    // Extract return type: everything between ") -> " and " {".
    returns := ""
    arrow := strings.index(sig[close:], "->")
    if arrow >= 0 {
        ret_start := close + arrow + 2
        // Find the opening brace.
        brace := strings.index(sig[ret_start:], "{")
        if brace >= 0 {
            returns = strings.trim_space(sig[ret_start:][:brace])
        } else {
            returns = strings.trim_space(sig[ret_start:])
        }
    }

    return Proc_Sig{
        name         = strings.clone(name, context.temp_allocator),
        link_name    = strings.clone(link_name, context.temp_allocator),
        params       = strings.clone(strings.trim_space(params), context.temp_allocator),
        returns      = strings.clone(returns, context.temp_allocator),
        is_variadic  = is_variadic,
        is_companion = is_companion,
    }
}

// Extract parameter names from a params string for forwarding calls.
// "config: Build_Config, args: []string" -> ["config", "args"]
@(private = "file")
_extract_param_names :: proc(params: string) -> []string {
    if len(strings.trim_space(params)) == 0 do return {}

    parts := strings.split(params, ",", context.temp_allocator)
    names := make([dynamic]string, context.temp_allocator)

    for part in parts {
        trimmed := strings.trim_space(part)
        if len(trimmed) == 0 do continue

        // Handle "name: Type" or "name: Type = default" or "name := default"
        // Also handle Odin shorthand: "output_path, input_path: string" where
        // the first part has no colon — the whole trimmed string is the name.
        colon := strings.index(trimmed, ":")
        if colon >= 0 {
            name := strings.trim_space(trimmed[:colon])
            append(&names, name)
        } else {
            // Shorthand param (no colon) — the entire trimmed string is the name.
            append(&names, trimmed)
        }
    }

    return names[:]
}

// Generate variadic wrapper procs for companion procs.
// For each _bld_xxx companion, generate a wrapper with the original name and variadic syntax.
@(private = "file")
_generate_variadic_wrappers :: proc(sb: ^strings.Builder, sigs: []Proc_Sig) {
    // Find companion procs and their corresponding original names.
    for ps in sigs {
        if !ps.is_companion do continue

        // The original name is the link_name without "bld_" prefix.
        original_name := ps.link_name[4:] if strings.has_prefix(ps.link_name, "bld_") else ps.link_name

        // Skip internal-only companions that don't need a public wrapper.
        // lib_odin_version is used internally by _load_bld for version checking only.
        if original_name == "lib_odin_version" do continue

        // Convert the params: replace "[]string" with "..string", "[]any" with "..any"
        // for the last parameter (or the variadic one).
        variadic_params := _make_variadic_params(ps.params)

        // Get param names for forwarding.
        param_names := _extract_param_names(ps.params)

        fmt.sbprintf(sb, "%s :: proc(%s)", original_name, variadic_params)
        if len(ps.returns) > 0 {
            fmt.sbprintf(sb, " -> %s", ps.returns)
        }
        strings.write_string(sb, " {\n")

        // The API field name matches the original name.
        field_name := original_name
        call_args := strings.join(param_names, ", ", context.temp_allocator)

        if len(ps.returns) > 0 {
            fmt.sbprintf(sb, "    return _api.%s(%s)\n", field_name, call_args)
        } else {
            fmt.sbprintf(sb, "    _api.%s(%s)\n", field_name, call_args)
        }
        strings.write_string(sb, "}\n\n")
    }
}

// Convert slice params back to variadic: "[]string" -> "..string", "[]any" -> "..any"
// Only converts the LAST slice parameter.
@(private = "file")
_make_variadic_params :: proc(params: string) -> string {
    // Find the last occurrence of "[]string" or "[]any" and replace with ".." version.
    result := strings.clone(params, context.temp_allocator)

    // Try []any first (log procs).
    if strings.contains(result, "[]any") {
        result, _ = strings.replace(result, "[]any", "..any", -1, context.temp_allocator)
    } else if strings.contains(result, "[]string") {
        result, _ = strings.replace(result, "[]string", "..string", -1, context.temp_allocator)
    }

    return result
}

// Strip default values from a params string for use in proc pointer type fields.
// Proc pointer types in structs cannot have defaults — only proc declarations can.
// Examples:
//   "allocator := context.allocator"  -> "allocator: mem.Allocator"
//   "allocator := context.temp_allocator" -> "allocator: mem.Allocator"
//   "opt: Cmd_Run_Opt = {}"           -> "opt: Cmd_Run_Opt"
//   "name: string"                    -> "name: string"  (unchanged)
@(private = "file")
_strip_defaults :: proc(params: string) -> string {
    if len(strings.trim_space(params)) == 0 do return params

    parts := strings.split(params, ",", context.temp_allocator)
    result_parts := make([dynamic]string, context.temp_allocator)

    for part in parts {
        trimmed := strings.trim_space(part)
        if len(trimmed) == 0 do continue

        walrus := strings.index(trimmed, ":=")
        if walrus >= 0 {
            // "name := context.allocator" or "name := context.temp_allocator"
            // The type is always mem.Allocator for these cases.
            name := strings.trim_space(trimmed[:walrus])
            append(&result_parts, fmt.tprintf("%s: mem.Allocator", name))
        } else {
            // Check for "name: Type = value" pattern.
            eq := strings.index(trimmed, " = ")
            if eq >= 0 {
                // Strip the " = value" part.
                append(&result_parts, strings.trim_space(trimmed[:eq]))
            } else {
                // No default — keep as-is.
                append(&result_parts, trimmed)
            }
        }
    }

    return strings.join(result_parts[:], ", ", context.temp_allocator)
}
